\documentclass[../main.tex]{subfiles}

\begin{document}

\chapter{Об’єктно-орієнтоване проектування ІС}

\section{Архітектурне проектування}

При створенні програмних систем перед розробниками часто постає проблема вибору тих чи інших проектних рішень. У цих випадках на допомогу приходять патерни. Справа в тому, що майже напевно подібні завдання вже вирішувалися раніше і вже існують добре продумані елегантні рішення, складені експертами. Якщо ці рішення описати і систематизувати в каталоги, то вони стануть доступними менш досвідченим розробникам, які після вивчення зможуть використовувати їх як шаблони або зразки для вирішення завдань подібного класу. Патерни якраз описують рішення таких завдань, що повторюються.

Концепція створення програмного забезпечення з використанням патернів, безсумнівно, дуже важлива, але відносно молода, можливо, тому до цих пір немає чіткого визначення, що ж таке патерн. Про це свідчать безперервні дискусії в популярній літературі і на відповідних форумах в мережі.

Наприклад, чи слід вважати алгоритми і структури даних паттернами? З цього питання існують протилежні думки. Відповідно до одного з них, алгоритми є обчислювальними паттернами, а добре відома фундаментальна монографія Дональда Кнута "Мистецтво програмування" по суті, являє собою каталог таких патернів. Згідно з іншим думку, алгоритми не є паттернами, так як можуть бути вирішені ними проблеми занадто малі (оперують такими поняттями як обчислювальна складність і споживання ресурсів), а область рішення добре окреслена. Патерни ж вирішують проблеми більшого масштабу, при цьому патерн дає не конкретне рішення, а якийсь шлях до вирішення, причому, вибір правильного патерну - завдання нетривіальне, що припускає від архітектора наявність інтуїції, досвіду, певного творчості.

В силу популярності каталогу GoF \cite{gof} часто під паттернами проектування мають на увазі всі види патернів програмної індустрії, що є не зовсім коректним. В області розробки програмних систем існує безліч паттернів, які відрізняються областю застосування, масштабом, вмістом, стилем опису. Наприклад, в залежності від сфери застосування існують такі патерни як патерни аналізу, проектування, тестування, документування, організації процесу розробки, планування проектів та інші.

В даний час найбільш популярними паттернами є патерни проектування. Однією з поширених класифікацій таких патернів є класифікація за ступенем деталізації і рівню абстракції розглянутих систем. Згідно \cite{pattern_oriented_arch}, патерни проектування програмних систем діляться на наступні категорії:

\begin{enumerate}
	\item Архітектурні паттерни.
	\item Патерни проектування.
	\item Ідіоми.
\end{enumerate}

Архітектурні патерни, будучи найбільш високорівневими паттернами, описують структурну схему програмної системи в цілому. В даній схемі вказуються окремі функціональні складові системи, звані підсистемами, а також взаємини між ними. Прикладом архітектурного патерну є добре відома програмна парадигма "модель-уявлення-контролер" (model-view-controller - MVC).

У свою чергу, підсистеми можуть складатися з архітектурних одиниць рівнем нижче. Патерни проектування описують схеми деталізації програмних підсистем і відносин між ними, при цьому вони не впливають на структуру програмної системи в цілому і зберігають незалежність від реалізації мови програмування. Патерни GoF відносяться саме до цієї категорії. Згідно \cite{gof}, під паттернами проектування об'єктно-орієнтованих систем розуміється опис взаємодії об'єктів і класів, адаптованих для вирішення загальної задачі проектування в конкретному контексті.

Ідіоми, будучи низькорівневими паттернами, мають справу з питаннями реалізації будь-якої проблеми з урахуванням особливостей даного мови програмування. При цьому часто одні й ті ж ідіоми для різних мов програмування виглядають по-різному або не мають сенсу зовсім. Наприклад, в C ++ для усунення можливих втрат пам'яті можуть використовуватися інтелектуальні покажчики. Інтелектуальний покажчик містить покажчик на ділянку динамічно виділеної пам'яті, який буде автоматично звільнений при виході із зони видимості. У середовищі Java такої проблеми просто не існує, так як там використовується автоматичне прибирання сміття. Зазвичай, для використання ідіом потрібно глибоко знати особливості застосовуваного мови програмування.

Слід зазначити, що в програмній області існують і інші види патернів, що не відносяться до проектування взагалі, наприклад, патерни аналізу, тестування, документування та ін.

Завдання кожного патерну - дати чіткий опис проблеми та її рішення у відповідній області. Для цього можуть використовуватися різні формати описів від художньо-описового \cite{pattern_language} до суворого, академічного \cite{gof}. У загальному випадку опис паттерна завжди містить такі елементи:

\begin{enumerate}
	\item Назву патерну. Являє собою унікальне смислове ім'я, що однозначно визначає цю задачу або проблему і її рішення.
	\item Задачу, котру потрібно вирішити. Тут дається розуміння того, чому розв'язувана проблема дійсно є такою, чітко описує її межі.
	\item Рішення. Тут вказується, як саме таке рішення пов'язане з проблемою, наводиться шляхи її вирішення.
	\item Результати використання патерну. Зазвичай наводяться переваги, недоліки і компроміси.
\end{enumerate}

Один зі співавторів GoF, Джон Вліссідес \cite{patterns_application} наводить такі переваги застосування патернів проектування:

\begin{enumerate}
	\item Вони (патерни) дозволяють підсумувати досвід експертів і зробити його доступним рядовим розробникам.
	\item Імена патернів утворюють свого роду словник, який дозволяє розробникам краще розуміти один одного.
	\item Якщо в документації системи зазначено, які патерни в ній використовуються, це дозволяє читачеві швидше зрозуміти систему.
	\item Патерни спрощують реструктуризацію системи незалежно від того, чи використовувалися патерни при її проектуванні.
\end{enumerate}

Правильно обрані патерни проектування дозволяють зробити програмну систему більш гнучкою, її легше підтримувати і модифікувати, а код такої системи в більшій мірі відповідає концепції повторного використання.

\subsection{Діаграми пакетів}

%TODO explain what each package contain

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{3_package_structure_client}
	\caption{Діаграма пакетів Android клієнту}
\end{figure}

\subsection{Діаграми компонентів}

%TODO explain what each class does

\begin{figure}[H]
	\centering
	\includegraphics[height=0.9\textheight]{3_hierarchy_client}
	\caption{Діаграма компонентів Android клієнту}
\end{figure}

\section{Детальне проектування}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{3_diagram_rest_api}
	\caption{Діаграма наявних REST ресурсів веб-серверу}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{3_client_models_diagram}
	\caption{Діаграма моделей даних Android клієнту}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{3_client_event_classes_diagram}
	\caption{Діаграма класів подій Android клієнту}
\end{figure}

\section{Розгортання програмної системи на апаратних засобах}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{3_diagram_deploy}
	\caption{Діаграма розгортання системи}
\end{figure}

\end{document}