\documentclass[../main.tex]{subfiles}

\begin{document}

\chapter{АНАЛІЗ І ПРОЕКТУВАННЯ БАГТРЕКЕРУ}

\section{Моделювання багтрекеру}

	Будь-який багтрекер є складною системою з великою кількістю взаємопов'язаних елементів. Основними сутностями типового багтрекеру є:
	\begin{enumerate}
		\item Користувач -- сутність, що відображує реального користувача та інформацію щодо нього у системі.
		\item Проект -- сутність, що відображує реальний проект та інформацію щодо нього у системі.
		\item Звіт -- сутність, що відповідає за збереження інформації щодо проблеми/пропозиції до програмного продукту.
	\end{enumerate}
	
	Окрім основних сутностей, роботу типового багтрекеру неможливо уявити без різноманітних додаткових сутностей. Всі вони є опціональними, але під час аналізу існуючих реалізацій було встановлено, що кожна з проаналізовних реалізацій містить функціональність, що потребує наявності в системі даних сутностей. До цього переліку належать:
	\begin{enumerate}
		\item Право -- сутність, що описує дозвіл на деяку взаємодію з системою. Роль може бути як глобальною, так і локальною для деякої групи користувачів, наприклад, учасників деякого проекту, що мають деяку роль.
		\item Роль -- сутність, що описує набір прав користувача. Може бути як глобальною, так і локальною, наприклад, в межах одного проекту або набору проектів.
		\item Додаток -- сутність, що забезпечує можливість прикріплення додаткової інформації до звіту.
		\item Статус -- сутність, що дозволяє описувати поточний стан звіту.
		\item Тег -- сутність, що дозволяє здійснювати швидкий пошук звіту за набором деяких ключових слів або словосполучень, зазначених автором звіту.
	\end{enumerate}

\section{Формування та аналіз вимог до багтрекінгової системи}

	Розглянувши існуючі на цей час програмні продукти для багтрекінгу, проаналізувавши їх, та виявивши як позитивні так і негативні їх сторони, можна сформулювати задачі розробки. В узагальненому вигляді такою задачею є створення програмного комплексу, що буде забезпечувати можливість легкого розгортання, підтримки та модифікації системи, а також надання публічного API для спілкування з клієнтами для будь-яких платформ.
	
	При проектуванні програмного продукту необхідно забезпечити наступні можливості:
	\begin{enumerate}
	  \item Авторизація за допомогою внутрішнього аккаунта.
	  \item Можливість управління проектами та їх учасниками.
	  \item Можливість управління правами учасників проекту.
	  \item Збереження даних щодо проблем/пропозицій.
	  \item Можливість прикріплення додаткових артефактів до кожного звіту.
	  \item Можливість написання клієнту під будь-яку платформу завдяки вікористанню розподіленої моделі взаємодії.
	  \item Синхронізація між пристроями користувачів.
	  \item Інтерфейсна частина клієнтського додатку повинна забезпечувати відображення списків проектів, проблем/пропозицій, інформації про проблему, додатків до проблеми.
	\end{enumerate}
	
	\subparagraph{Авторизація за допомогою внутрішнього аккаунта.}
		Для того, щоб багтрекінгова система працювала, кожний користувач повинен мати свій обліковий запис в базі даних. Серед варіантів реалізації авторизації є два основних підходи: використання власної бази облікових записів або використання стороннього сервісу облікових записів. Реалізація підходу з використанням стороннього сервісу авторизації має декілька проблем:
		\begin{enumerate}
			\item Можливість зміни механізму авторизації третьою стороною (що автоматично унеможливлює авторизацію).
			\item Відсутність можливості контролю методу зберігання облікових записів та даних користувачів.
		\end{enumerate}
		
		Зважаючи на перелічені недоліки підходу зі стороннім сервісом авторизації було вирішено написати власну систему авторизації.
	
	\subparagraph{Можливість управління проектами та їх учасниками.}
	Для функціонування багтрекінгової системи в умовах надання публічного API необхідно мати можливість логічного розподілення звітів серед існуючих проектів. Кожен користувач повинен мати змогу створити свій проект та керувати ним:
	\begin{enumerate}
		\item Додавати/змінювати інформацію щодо проекту.
		\item Додавати/видаляти учасників.
		\item Керувати правами учасників.
	\end{enumerate}
	
	\subparagraph{Можливість управління правами учасників проекту.}
	Система повинна мати розгалуджену систему управління правами щоб забезпечити виконання таких пунктів:
	\begin{enumerate}
		\item Кожен окремий користувач повинен мати окремий набір прав для кожного з проектів, в яких він бере участь.
		\item Користувач з правами адміністратора проекту може створювати, редагувати та видаляти будь-які ролі в цьому проекті окрім ролі ''творця''.
		\item Жоден користувач, що створив проект, не~може буде позбавлений прав в рамках даного проекту.
		\item Будь-яка дія, що потребує наявності у користувача деяких прав, не~може бути виконана, якщо користувач не має даного права.
	\end{enumerate}
	
	\subparagraph{Збереження даних щодо проблем/пропозицій.}
	Основою будь-якої системи багтрекінгу є збереження даних, наявних у звітах. Для забезпечення цієї вимоги повинна бути наявною база даних проблем/пропозицій.
	
	\subparagraph{Можливість прикріплення додаткових артефактів до кожного звіту.}
	Для вирішення проблеми, що зазначена у звіті, окрім словесного пояснення проблеми корисно мати додаткові дані (такі як stack trace помилки, скріншот, фрагмент логу, тощо). Для забезпечення даної вимоги необхідно передбачити механізм збереження додатку до звіту у базі даних.
	
	\subparagraph{Можливість написання клієнту під будь-яку платформу завдяки вікористанню розподіленої моделі взаємодії.}
	Модель з наданням публічного API для взаємодії з багтрекінговим сервісом дозволяє стороннім розробникам створювати клієнтські додатки під будь-які платформи, що їх цікавлять. Таким чином досягається свобода від конкретної імплементації клієнтського додатку та можливих проблем, пов'язаних з ним. Також такий підхід дозволяє стороннім розробникам власноруч впроваджувати нові особливості на стороні клієнту (а в сукупності з вільною open source ліцензією на всі компоненти системи і можливістю самостійного розгортання на власному сервері, також і на стороні сервера).
	
	\subparagraph{Синхронізація між пристроями користувачів.}
	Синхронізація між пристроями користувачів має бути забезпечена за допомогою взаємодії клієнтських додатків з серверною частиною. Таким чином, будь-яка підтверджена дія над сутністю, отриманою з сервера, має бути відправлена на сервер для того щоб усі інші користувачі системи могли побачити змінену версію сутності в своєму клієнтському додатку.
	
	\subparagraph{Інтерфейсна частина клієнтського додатку повинна забезпечувати відображення списків проектів, проблем/пропозицій, інформації про проблему, додатків до проблеми.}
	Оскільки для взаємодії з системою необхідний клієнтський додаток, то він повинен забезпечувати забезпечувати відображення актуальної інформації з серверу у формі, прийнятній для взаємодії з нею.

\section{Об'єктний аналіз вимог до багтрекеру}

	\subsection{Формулювання вимог до багтрекінгової системи за допомогою діаграми прецедентів}
	
	Кожен користувач, що в рамках проекту має право на це, повинен мати можливість створення звіту щодо проблеми або пропозіції з покращення продукту. Як тільки створення звіту завершено, усі члени проекту повинні отримати сповіщення щодо цієї події, а сам автор має побачити фінальну версію звіту таким, як його бачитимуть усі інші учасники проекту.
	
	Щойно створений звіт повинен завжди мати статус ''відкритий''. Коли член команди отримує сповіщення щодо нового звіту — він повинен мати змогу його відкрити та виставити статус, який він вважає доцільним. Також, якщо член команди має право на це, то він повинен мати змогу назначити відповідальних за зміну продукту таким чином, щоб він вирішував зазначені у звіті проблеми або впроваджував новий функціонал, котрого не вистачає користувачу, що створював звіт.
	
	\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{diagram_usecase_1}
	\caption{Діаграма прецедентів при роботі зі звітами в багтрекері}
	\end{figure}
	
	\subsection{Формулювання та аналіз вимог до багтрекеру за допомогою діаграми діяльності}
	
	Процес створення звіту, що знаходится в процесі обробки персоналом проекту, має трьох основних учасників: користувач, відповідальний член команди, а також член команди з правом назначення відповідальних за звіт. Щоб звіт дійшов до стадії ''в процесі'', після створення користувачем звіту його повинен перегланути член команди, що має право назначення відповідальних та назначити відповілальних за цей звіт осіб. Після цього, відповідильний член команди може назначити звіту той статус, який вважає потрібним, і, в тому випадку, якщо це доцільно, приступити до вирішення проблеми/впровадження нового функціоналу, при цього змінивши статус звіту на ''в процесі''.
	
	\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{diagram_activity_1}
	\caption{Діаграма діяльності при роботі зі звітами в багтрекері}
	\end{figure}
	
	\subsection{Аналіз вимог до багтрекінгової системи за допомогою діаграми послідовності}
	
	При створенні звіту, користувач може побажати прикріпити важливу інформацію, пов'язану з цим звітом. В такому випадку, йому клієнтський додаток повинен спочатку завантажити додаткову інформацію на спеціально відведений для цього сервер, і вже потім, якщо користувач має на це право, оновити дані звіту, додавши до них посилання на додаткову інформацію, як зображено на діаграмі~\ref{figure_diag_seq_1}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.75\textwidth]{diagram_seq_1}
		\caption{Діаграма послідовності при створенні звіту з додатками в багтрекері}
		\label{figure_diag_seq_1}
	\end{figure}
	
	\subsection{Аналіз вимог до багтрекеру за допомогою діаграми комунікації}
	
	Діаграми комунікації відображають взаємодію ролей або об'єктів у процесі функціонування системи, описують обмін даними (повідомленнями) між різними учасниками взаємодії. Такі діаграми моделюють сценарії поведінки системи.~\cite{chnu_designing_systems}
	
	Будь-яка система обліку повинна давати можливість пошуку та перегляду інформації. Багтрекінгові системи, як підвид систем обліку, в свою чергу також повинні надавати можливість створення звітів. Механізм перегляду проектів та звітів у вигляді діаграми комунікації зображено на діаграмі \ref{figure_diag_comm_1}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.875\textwidth]{diagram_communication_1}
		\caption{Діаграма комунікації при перегляді проектів та звітів в багтрекері}
		\label{figure_diag_comm_1}
	\end{figure}

\section{Об’єктно-орієнтоване проектування багтрекінгової системи}

	\subsection{Архітектурне проектування багтрекеру}
	
		При створенні програмних систем перед розробниками часто постає проблема вибору тих чи інших проектних рішень. У цих випадках на допомогу приходять патерни. Справа в тому, що майже напевно подібні завдання вже вирішувалися раніше і вже існують добре продумані елегантні рішення, складені експертами. Якщо ці рішення описати і систематизувати в каталоги, то вони стануть доступними менш досвідченим розробникам, які після вивчення зможуть використовувати їх як шаблони або зразки для вирішення завдань подібного класу. Патерни якраз описують рішення таких завдань, що повторюються.~\cite{uml_patterns}
		
		Концепція створення програмного забезпечення з використанням патернів, безсумнівно, дуже важлива, але відносно молода, можливо, тому до цих пір немає чіткого визначення, що ж таке патерн. Про це свідчать безперервні дискусії в популярній літературі і на відповідних форумах в мережі.
		
%		Добре відома фундаментальна монографія Дональда Кнута ''Мистецтво програмування'' по суті являє собою каталог таких патернів. Згідно з іншою думкою, алгоритми не є паттернами, так як можуть бути вирішені ними проблеми занадто малі (оперують такими поняттями як обчислювальна складність і споживання ресурсів), а область рішення добре окреслена. Патерни ж вирішують проблеми більшого масштабу, при цьому патерн дає не~конкретне рішення, а якийсь шлях до вирішення, причому, вибір правильного патерну — завдання нетривіальне, що припускає від архітектора наявність інтуїції, досвіду, певного творчості.~\cite{design_patterns}
		
		В силу популярності каталогу GoF \cite{gof} часто під паттернами проектування мають на увазі всі види патернів програмної індустрії, що є не зовсім коректним. В області розробки програмних систем існує безліч паттернів, які відрізняються областю застосування, масштабом, вмістом, стилем опису. Наприклад, в залежності від сфери застосування існують такі патерни як патерни аналізу, проектування, тестування, документування, організації процесу розробки, планування проектів та інші.~\cite{elemental_design_patterns}
		
		В даний час найбільш популярними паттернами є патерни проектування. Однією з поширених класифікацій таких патернів є класифікація за ступенем деталізації і рівню абстракції розглянутих систем. Згідно \cite{pattern_oriented_arch}, патерни проектування програмних систем діляться на наступні категорії:
		
		\begin{enumerate}
			\item Архітектурні паттерни.
			\item Патерни проектування.
			\item Ідіоми.
		\end{enumerate}
		
		Архітектурні патерни, будучи найбільш високорівневими паттернами, описують структурну схему програмної системи в цілому. В даній схемі вказуються окремі функціональні складові системи, звані підсистемами, а також взаємини між ними. Прикладом архітектурного патерну є добре відома програмна парадигма ''модель-уявлення-контролер'' (model-view-controller — MVC).
		
		У свою чергу, підсистеми можуть складатися з архітектурних одиниць рівнем нижче. Патерни проектування описують схеми деталізації програмних підсистем і відносин між ними, при цьому вони не впливають на структуру програмної системи в цілому і зберігають незалежність від реалізації мови програмування. Патерни GoF відносяться саме до цієї категорії. Згідно \cite{gof}, під паттернами проектування об'єктно-орієнтованих систем розуміється опис взаємодії об'єктів і класів, адаптованих для вирішення загальної задачі проектування в конкретному контексті.
		
		Ідіоми, будучи низькорівневими паттернами, мають справу з питаннями реалізації будь-якої проблеми з урахуванням особливостей даної мови програмування. При цьому часто одні й ті ж ідіоми для різних мов програмування виглядають по-різному або не мають сенсу зовсім. Наприклад, в C++ для усунення можливих втрат пам'яті можуть використовуватися інтелектуальні покажчики. Інтелектуальний покажчик містить покажчик на ділянку динамічно виділеної пам'яті, який буде автоматично звільнений при виході із зони видимості. У середовищі Java такої проблеми просто не існує, так як там використовується автоматичне прибирання сміття. Зазвичай, для використання ідіом потрібно глибоко знати особливості застосовуваної мови програмування.
		
		Слід зазначити, що в програмній області існують і інші види патернів, що не відносяться до проектування взагалі, наприклад, патерни аналізу, тестування, документування та ін.
		
		Завдання кожного патерну — дати чіткий опис проблеми та її рішення у відповідній області. Для цього можуть використовуватися різні формати описів від художньо-описового \cite{pattern_language} до суворого, академічного \cite{gof}. У~загальному випадку опис паттерна завжди містить такі елементи:
		
		\begin{enumerate}
			\item Назву патерну. Являє собою унікальне смислове ім'я, що однозначно визначає цю задачу або проблему і її рішення.
			\item Задачу, котру потрібно вирішити. Тут дається розуміння того, чому розв'язувана проблема дійсно є такою, чітко описує її межі.
			\item Рішення. Тут вказується, як саме таке рішення пов'язане з проблемою, наводиться шляхи її вирішення.
			\item Результати використання патерну. Зазвичай наводяться переваги, недоліки і компроміси.
		\end{enumerate}
		
		Один зі співавторів GoF, Джон Вліссідес \cite{patterns_application} наводить такі переваги застосування патернів проектування:
		
		\begin{enumerate}
			\item Вони (патерни) дозволяють підсумувати досвід експертів і зробити його доступним рядовим розробникам.
			\item Імена патернів утворюють свого роду словник, який дозволяє розробникам краще розуміти один одного.
			\item Якщо в документації системи зазначено, які патерни в ній використовуються, це дозволяє читачеві швидше зрозуміти систему.
			\item Патерни спрощують реструктуризацію системи незалежно від того, чи використовувалися патерни при її проектуванні.
		\end{enumerate}
		
		Правильно обрані патерни проектування дозволяють зробити програмну систему більш гнучкою, її легше підтримувати і модифікувати, а код такої системи в більшій мірі відповідає концепції повторного використання.
	
		\subparagraph{Діаграми пакетів.}
		
			Як зображено на діаграмі \ref{server_packages}, серверна частина складається з таких пакетів:
			\begin{itemize}
				\item \enquote{api} — містить основний код серверної частини;
				\item \enquote{controllers} — містить код обробників запитів до серверу;
				\item \enquote{helpers} — містить код компонентів, що використовуються різними обробниками;
				\item \enquote{sql} — містить код компонентів для роботи з реляційною БД;
				\item \enquote{swagger} — містить код компонентів, що використовуються різними обробниками;
				\item \enquote{config} — містить конфігураційні файли;
				\item \enquote{test} — містить тести серверної частини.
			\end{itemize}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=0.75\textwidth]{3_backend_packages}
				\caption{Діаграма пакетів серверної частини багтрекеру}
				\label{server_packages}
			\end{figure}
			
			
			Діаграма \ref{client_packages} показує структуру пакетів клієнтського Android додатку. Він складається з таких пакетів:
			\begin{itemize}
				\item \enquote{api} — містить опис інтерфейсу взаємодії з серверною частиною;
				\item \enquote{bundlers} — містить опис серіалізаторів нестандартних типів;
				\item \enquote{events} — містить опис подій, на яких базується взаємодія в додатку;
				\item \enquote{models} — містить опис моделей даних;
				\item \enquote{prefs} — містить опис користувацьких налаштувань;
				\item \enquote{screens} — містить опис екранів додатку;
				\item \enquote{base} — містить опис базових класів сущностей користувацького інтерфейсу;
				\item \enquote{utils} — містить код утилітарних класів;
				\item \enquote{adapters} — містить опис адаптерів для різноманітних списків;
				\item \enquote{di} — містить опис класів, потрібних для реалізації ін'єкції залежностей;
				\item \enquote{ui} — містить опис класів, що використовуються для побудови користувацького інтерфейсу.
			\end{itemize}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=1\textwidth]{3_package_structure_client}
				\caption{Діаграма пакетів Android клієнту багтрекеру}
				\label{client_packages}
			\end{figure}
		
		\subparagraph{Діаграми компонентів.}
		
			Точкою входу клієнтського додатку є клас \enquote{App}. Для того, щоб система могла створити його екземпляр та запустити додаток за допомогою нього, він унаслідуваний від системного класу \enquote{Application} та заздалегідь прописаний в \enquote{AndroidManifest.xml}. Кожна активність в додатку є наслідуваною від класу \enquote{BaseActivity}. Таким чином досягається розповсюдження базової логіки на кожну конкретну активність. Для відображення списків в коді передбачено класи, іменовані у стилі \enquote{<Назва списку>Adapter} та \enquote{<Назва списку>Item}. Таким чином, забезпечується інкапсуляція даних щодо кожного елементу списку та конвертації даних цього елементу в звичний для користувача візуальний вигляд. Детальніше, структура комнонентів зображена на діаграмі \ref{client_components}.
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=1\textwidth]{3_hierarchy_client}
				\caption{Діаграма компонентів Android клієнту багтрекеру}
				\label{client_components}
			\end{figure}
	
	\subsection{Детальне проектування багтрекінгової системи}
	
		Для детального проектування серверної частини було застосовано Swagger — фреймворк для опису специфікації REST API. Наявність опису API такого формату є додатковою основою стабільності остаточного продукту, оскільки він дозволяє командам, що працюють над різними частинами системи, знати всі необхідні для взаємодії з сервером дані ще до того, як сервер введений у дію. Опис API за допомогою Swagger передбачає опис наявних моделей даних та доступних REST ресурсів. Діаграма \ref{available_rest_resources} відображає результат проектування за допомогою Swagger.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{3_diagram_rest_api}
			\caption{Діаграма наявних REST ресурсів веб-серверу багтрекінгової системи}
			\label{available_rest_resources}
		\end{figure}
		
		Використання Swagger дозволяє візуально оцінити необхідні методи взаємодії з серверною частиною (див. рис. \ref{available_rest_endpoints}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.6\textwidth]{3_backend_endpoints}
			\caption{Список необхідних методів взаємодії з сервером багтрекінгової системи}
			\label{available_rest_endpoints}
		\end{figure}
		
		Кожен з методів взаємодії має один з чотирьох типів: GET, POST, PATCH або DELETE. Також, кожен з методів взаємодії має свій колів. Якщо для взаємодії потрібен URI параметр, то його повинно бути вказано на місці тексту, обрамленого фігурними скобками. Якщо присутні декілька параметрів у фігурних скобках - вони всі повинні бути надані серверу при виконанні запиту, інакше буде отримана помилка 404.
		
		Іменування кожного з методів слідує одному і тому ж стилю -- ''<група>/<ідентифікатор>''. Якщо користувач хоче отримати вкладену сутність -- метод матиме назву такого вигляду: ''<група>/<ідентифікатор>/<група>/<ідентифікатор>''.
		
		Усі методи взаємодії, окрім DELETE, повертають сутність або набір сутностей в ролі результату. DELETE методи не повертають нічого, оскільки призначені для видаленя сутностей з системи.
		
		Наявність іконки \enquote{замку} в описі методу взаємодії свідчить про необхідність авторизації для його використання. Лише методи реєстрації а отримання токену доступу можуть бути використані без авторизації, оскільки вони є авторизуючими методами.
		
		Завдяки наявності специфікації взаємодії з сервером, існує можливість генерації моделей даних для різних платформ, в тому числі і для мобільних додатків. Таким чином, моделі даних можуть бути згенеровані для клієнтського додатку, що спрощує імплементацію взаємодії з сервером. Тому, моделі даних для Android клієнту матимуть вигляд, представлений на діаграмі \ref{client_models}.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{3_client_models_diagram}
			\caption{Діаграма моделей даних Android клієнту багтрекеру}
			\label{client_models}
		\end{figure}
		
		Для реалізації гнучкої архітектури клієнтського додатку було вирішено використовувати архітектуру, що основується на подіях. На діаграмі \ref{client_events} представлено доступні класи подій Android клієнту.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{3_client_event_classes_diagram}
			\caption{Діаграма класів подій Android клієнту багтрекеру}
			\label{client_events}
		\end{figure}
	
	\subsection{Розгортання багтрекеру на апаратних засобах}
	
		Оскільки предметом даної роботи є саме клієнт-серверна система, то розгортання такої системи буде проводитись у декілька етапів:
		\begin{enumerate}
			\item Встановлення на серверну машину середовища виконання Node.js.
			\item Забезпечення працездатності серверу бази даних.
			\item Конфігурація серверу.
			\item Розповсюдження клієнтських додатків учасникам системи.
		\end{enumerate}
		
		Візуальна демонстрація розгортання системи представлена на рис.~\ref{diagram_deploy}. % to fit all paragraph to one line; otherwise it's either too underfilled or has too short 2nd line
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{3_diagram_deploy}
			\caption{Діаграма розгортання багтрекінгової системи}
			\label{diagram_deploy}
		\end{figure}

\section{Висновки до другого розділу}
	В даному розділі було сформульовано та проаналізовано вимоги до реалізації багтрекеру, було спроектовано систему для подальшої її імплементації. За допомогою діаграм було продемонстровано структурний розподіл елементів, набір компонентів, набір методів та форматів повідомлень для взаємодії з сервером. Також було розглянуто механізм впровадження системи. 
	
	Грунтуючись на оцінці недоліків і переваг одних методів вирішення проблем перед іншими та беручи до уваги реалізацію подібних можливостей в аналогах, було внесено корективи до кінцевих вимог. В результаті аналізу отриманих вимог було виконано чотири діаграми різних типів для їх візуального представлення.
	
	За допомогою діаграми прецедентів було показано можливі методи взаємодії з системою різними її учасниками. За допомогою діаграми діяльності було показано потік взаэмодії з системою при створенні звіту. За допомогою діаграми послідовності було показано послідовність виконання дій різними елементами системи. За допомогою діаграми комунікації було зображено напрям взаємодії з елементами системи.
	
	Також у розділі було розглянуто специфікацію серверної частини більш детально. Описані у специфікації елементи знайшли своє втілення у вигляді методів відповідних класів і саме вони забезпечують функціональні можливості взаємодії клієнту і серверу отриманої системи. Окрім цього, було прийнято рішення про реалізацію взаємодії елементів користувацього інтерфейсу клієнтського Android додатку за допомогою системи сповіщень. Такий підхід дозволяє знизити зв'язаність компонентів системи, що сприяє підвищенню стабільності додатку.

\end{document}